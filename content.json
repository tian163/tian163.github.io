{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Sun Zetian","url":"http://example.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"06-15","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"06-15","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"06-15","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-15","excerpt":""}],"posts":[{"title":"css","text":"1.什么是css ​ 1.1 ​ Cascading Style Sheet层叠样式表 ​ css:表现(美化网页) ​ 字体，颜色，边距，高度，宽度…… ​ 1.2发展史 ​ css 1.0 ​ css 2.0 DIV(块)+CSS，HTML与CSS结构分离的思想，网页变得简单 ​ css 2.1 浮动，定位 ​ css 3.0 圆角，阴影，动画… 浏览器兼容性 ​ 1.3快速入门 ​ 语法: ​ 外部引入：&lt;link rel=”stylesheet” href=”” &gt; ​ 选择器{ ​ 声明1; ​ 声明2; ​ 声明3; ​ } ​ css优势 ​ 1.内容和表现分离 ​ 2.网页结构统一表现，可以实现复用 ​ 3.样式十分的丰富 ​ 4.建议使用独立于html的css文件 ​ 5.利于SEO，容易被搜索引擎收录 ​ 1.4css的三种导入方式 ​ 行内样式：在标签元素中，编写一个style属性 &lt;h1 style=&quot;color: red&quot;&gt;我是标题&lt;/h1&gt; ​ 内部样式： 12345&lt;style&gt; h1&#123; color: green; &#125;&lt;/style&gt; ​ 外部样式： 12345h1&#123; color: blue;&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; ​ 优先级：就近原则 拓展:外部样式两种写法 ​ 链接式 1&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; ​ 导入式 123&lt;style&gt; @import &quot;css/style.css&quot;;&lt;/style&gt; 2.css选择器 作用：选择页面上的摸一个或者某一类元素 优先级：不遵循就近原则，id选择器&gt;类选择器&gt;标签选择器 2.1基本选择器 ​ 1.标签选择器，会选择到页面上所有的这个标签元素 ​ 2.类选择器 class，可以多个标签归类，是同一个class，跨标签 ​ 格式： ​ .class的名称{ ​ } ​ 3.Id选择器,id必须保证全局唯一 ​ 格式： ​ #id名称{ ​ } 2.2层次选择器 ​ 1.后代选择器：在某个元素的后面 123body p&#123; background: red;&#125; ​ 2.子选择器:一代,儿子 123body&gt;p&#123; background: blue;&#125; ​ 3.相邻兄弟选择器:同辈,只有一个，相邻（向下） 123.active +p&#123; background: green;&#125; ​ 4.通用兄弟选择器：当前选中元素向下的所有兄弟 123.active~p&#123; background:yellow;&#125; 2.3.结构伪类选择器 伪类：行为 123456789101112131415161718 /*选中ul中的第一个元素*/ ul li:first-child&#123; background: cornflowerblue; &#125; /*选中ul中的最后一个元素*/ ul li:last-child&#123; background: cornflowerblue; &#125;/*选中p1:定位到父元素，选择当前的第一个元素 选中当前p元素的父级元素，选中父级元素的第一个，并且是当前元素才生效！ */ p:nth-child(1)&#123; background: #188037; &#125; /*选中父元素下的p元素的第二个*/ p:nth-of-type(2)&#123; background: #488077; &#125; a:hover //鼠标悬浮的颜色 a:active //激活：鼠标按住未释放的状态 2.4属性选择器(常用) id+class结合 属性名，属性名 = 属性值(正则) 1234=绝对等于*=包含^=以...开头$=以...结尾 3.美化网页(文字，阴影，超链接，列表，渐变) span标签：重点要突出的字，使用span套起来 ​ 3.1字体样式 ​ font-family:字体 ​ font-size:字体大小 ​ font-weight:字体粗细 ​ color:字体颜色 ​ px:像素 ​ em:缩进 ​ 3.2文本样式 ​ 1.颜色 ​ 单词 ​ RGB 0~F ​ RGBA(0255) A(透明度)：01 ​ 2.文本对齐 ​ text-align:center排版居中 ​ 3.首行缩进 ​ text-indent:2em; 段落首行缩进 ​ 4.行高 ​ line-height ​ 行高和块的高度一致，就可以上下居中 ​ 5.超链接去下划线 ​ text-decoration:none ​ 6.文本图片水平对齐 ​ vertical-align：middle ​ 7.列表 ​ list-style: ​ none 去掉圆点 ​ circle 空心圆 ​ decimal 数字 ​ 8.背景 ​ border：框线 ​ 背景颜色：background-color ​ 背景图片:background-image 5.盒子模型 ​ 5.1什么是盒子模型 margin:外边距 padding:内边距 border:边框 ​ 5.2边框 ​ 1.边框的粗细 ​ 2.边框的样式 solid：实线 dashed：虚线 ​ 3.边框的颜色 ​ border:粗细 样式 颜色 ​ 外边距的妙用：居中元素 要求：块元素，块元素有固定的宽度 ​ margin：0 auto ​ 盒子的计算方式 ​ margin+border+padding+内容宽度 ​ 5.3圆角边框 ​ border-radius ​ 5.4阴影 6.浮动 1块级元素(block)：独占一行 ​ h1~h6 p div 列表 ​ 行内元素(inline)：不独占一行 ​ span a img strong ​ inline-block:保留块级元素特性但可以写在一行 ​ 行内元素可以包含在块级元素中，反之则不行 ​ 6.2display ​ float左右浮动 ​ 6.3父级边框塌陷问题 ​ clear：right；右侧不允许有浮动元素 ​ clear：left； 左侧不允许有浮动元素 ​ clear：both； 两侧都不允许有浮动元素 ​ clear：none； ​ 解决方案： ​ 1.增加父级元素的高度 ​ 2.增加一个空的div标签，清除浮动 ​ 3.在父级元素中增加一个overflow：hidden； ​ 4.父类添加一个伪类 ：after 12345#father:after&#123; content:&#x27;&#x27;; display:block; clear:both;&#125; 7.定位 ​ 7.1相对定位 ​ position:relative 相对原来的位置进行上下左右的偏移,保留原来位置 ​ 7.2绝对定位 ​ position:absolute; 相对于父级或浏览器的位置1进行指定的偏移，不在标准文档流中，原来的位置不被保留 ​ 1.没有父级元素的基于浏览器定位 ​ 2.假设父级元素存在定位，我们通常会相对于父元素进行定位 ​ 7.3 固定定位 ​ position：fixed； ​ 7.4 z-index 默认0 8.网页动画(特效效果)","path":"2021/07/16/css/","date":"07-16","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"html","text":"1.html注释 2. 网页头部 3. 网页主体 4. 网页标题 5. 描述性标签，用来描述网站的信息 基本标签： 1.标题标签 h1-h6 一级标签 二级标签 段落标签 p 换行标签 br 水平线标签 hr 字体样式标签 ​ 粗体：strong粗体 ​ 斜体：em斜体 特殊符号 空格：&amp;nbsp； ​ 空&nbsp;&nbsp;格 大于号：&amp;gt； 小于号：&amp;lt； 版权符号：&amp;copy； 2.常见的图片格式 ​ JPG ​ GIF ​ PNG ​ BMP 位图 嵌入图片：&lt;img src=”path” alt=”text” title=”text” width=”x” height=”y” /&gt; 3.链接标签：&lt;a href=” “ target=” “&gt;&lt;/a&gt; ​ href: 必填，表示要跳转到哪个页面 ​ target:表示窗口在哪里打开 ​ _blank 在新标签打开 ​ _self 在自己的网页中打开 锚链接： ​ 1.需要一个锚标记 ​ 2.跳转到标记 使用name做标记，#name跳转 功能性链接： ​ 邮件链接：mailto: ​ &lt;a href=”mailto:&#x35;&#x35;&#54;&#56;&#55;&#x33;&#x35;&#x38;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;“ &gt;&lt;/a&gt; 行内元素和块元素 块元素： ​ 无论内容多少，该元素独占一行 行内元素： ​ 内容撑开宽度，左右都是行内元素的可以排在一行 列表 ​ 有序列表 ​ &lt;ol&gt; ​ &lt;li&gt;&lt;/li&gt; ​ &lt;/ol&gt; ​ 无序列表(应用范围：导航栏、侧边栏……) ​ &lt;ul&gt; ​ &lt;li&gt;&lt;/li&gt; ​ &lt;/ul&gt; ​ 自定义列表 ​ dl:标签 ​ dt:列表名称 ​ dd:列表选项 ​ &lt;dl&gt; ​ &lt;dt&gt;&lt;/dt&gt; ​ &lt;dd&gt;&lt;/dd&gt; ​ &lt;/dl&gt; 表格table： ​ 行：tr rows ​ 列：td colspan：跨列 rowspan：跨行 视频video ​ &lt;video src=”” controls autoplay&gt;&lt;/video&gt; 音频audio ​ &lt;audio src=”” controls autoplay&gt;&lt;/audio&gt; 页面结构分析 header：标题头部区域的内容 footer：标记脚步区域的内容 section：Web页面中的一块独立区域 article：独立的文章内容 aside：相关内容或应用(常用于侧边栏) nav:导航类辅助内容 iframe内联框架 ​ &lt;iframe src=” “ frameborder=”0” width=” “ height=” “&gt;&lt;/iframe&gt; 表单语法 ​ action:表单提交的位置，可以是网站，也可以是一个请求处理地址 ​ method: post，get 提交方式 ​ get方式提交：我们可以在url中看到我们提交的信息，不安全，高效 ​ post方式：比较安全，传输大文件 ​ &lt;form action=”#” method=”get”&gt;&lt;/form&gt; ​ ​ &lt;p&gt;名字：&lt;input type=”text” name=”username”&gt;&lt;/input&gt;&lt;/p&gt; ​ ​ &lt;p&gt;名字：&lt;input type=”password” name=”pwd”&gt;&lt;/input&gt;&lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”radio” value=”boy” name=”sex”/&gt;男 ​ &lt;input type=”radio” value=”girl” name=”sex”/&gt;女 ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”checkbox” value=”sleep” name=”hobby”/&gt;睡觉 ​ &lt;input type=”checkbox” value=”code” name=”hobby”/&gt;敲代码 ​ &lt;input type=”checkbox” value=”chat” name=”hobby”/&gt;聊天 ​ &lt;input type=”checkbox” value=”game” name=”hobby”/&gt;游戏 ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”button” name=”btn1” value=” “&gt; //普通按钮 ​ &lt;input type=”image” src=” “&gt; //图像按钮 ​ &lt;/P&gt; ​ ​ &lt;p&gt;下拉框： ​ &lt;select name=”列表名称”&gt; ​ &lt;option value=”选项的值”&gt;&lt;/option&gt; ​ &lt;/select&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt;反馈： ​ &lt;textarea name=”textarea”&gt;&lt;/textarea&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”file” name=”files”&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt;&lt;input type=”submit” &gt;&lt;input type=”reset”&gt;&lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”email” name=”email”&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”url” name=”url”&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”number” name=”number” max=”100” min=”0” step=”10”&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”range” name=”voice” max=”100” min=”0” step=”10”&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”search” name=”search”&gt; ​ &lt;/p&gt; &lt;label for=”mark”&gt;&lt;/label&gt; &lt;input type=”text” id=”mark”&gt; 隐藏域 hidden 只读 readonly 禁用 disabled 表单初级验证 placeholder 提示信息 required 非空判断 pattern 正则表达式","path":"2021/07/14/html/","date":"07-14","excerpt":"","tags":[{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"}]},{"title":"IO流","text":"1.流：流动、流向，从一端移动到另一端。流是一个抽象、动态的概念，是一连串连续动态的数据集合。 2.核心类： File 文件类 由File类提供了描述文件和目录的操作与管理方法。但File类不是InputStream、OutputStream或Reader、Writer的子类，因为它不负责数据的输入输出，而专门用来管理磁盘文件与目录。 四大抽象类： InputStream 字节输入流 OutputStream 字节输出流 Reader 字符输入流 Writer 字符输出流 Closeable 关闭流接口 Flushable 刷新流接口 Serializable 序列化接口 3.名称分隔符 建议 1./ path=”D:/java300/IO_study01/IO.png”; 2.常量拼接 path=”D:”+File.separator+”java300”+File.separator+”IO_study01”+File.separator+”IO_png”; 3.构造File对象 4.File常用方法 getName() 获取名字 getPath() 获取路径 getAbsolutePath() 返回绝对路径 getParent() 返回上路径，如果没有返回空 exists() 判断是否存在 isFile() 判断是否是文件 isDirectory() 判断是否是文件夹 length() 获取文件大小，字节数 createNewFile() 创建新文件，不存在才创建 delete() 删除文件 mkdir() 创建目录必须保证父目录存在 mkdirs() 创建目录，如果父路径不存在会自动创建父目录 list() 获取下级名称 listFiles() 获取下级File对象 listRoots() 根目录 5. 编码:字符(能看懂的)–&gt;字节(看不懂的) 解码:字节(看不懂的)–&gt;字符(能看懂的) 代码解释则是 12345678String(byte[] bytes, String charsetName):通过指定的字符集解码字节数组byte[] getBytes(String charsetName):使用指定的字符集合把字符串编码为字节数组编码:把看得懂的变成看不懂的String -- byte[]解码:把看不懂的变成看得懂的byte[] -- String 6.IO流操作步骤 ​ 1.创建流 ​ 2.选择流 ​ 3.操作 ​ 4.释放资源 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;public class IoTest &#123; public static void main(String[] args) &#123; //创建源 File src=new File(&quot;E:/ideajavaproject/debugtest/test01/src/test02.txt&quot;); //选择流 InputStream is =null; try &#123; is = new FileInputStream(src); /*int temp =is.read(); 这样写把temp定死了是第一个字符 所以下边的循环会成为死循环，循环输出第一个字符 while (temp!=-1)&#123; System.out.println((char)temp); &#125;*/ int temp; //只有这样写在下边执行循环时才能每次给temp赋值，每次取下一个，直到读取完返回-1，循环结束 while((temp=is.read())!=-1)&#123; System.out.println((char)temp); &#125; /*int date1 =is.read(); int date2 =is.read(); int date3 =is.read(); int date4 =is.read(); int date5 =is.read(); System.out.println((char)date1); System.out.println((char)date2); System.out.println((char)date3); System.out.println((char)date4); System.out.println((char)date5);*/ &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (null!=is) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 7.输出流在使用后要flush，避免数据驻留在内存中。 8.文件copy 示例代码： 123456789101112131415161718192021222324252627282930313233343536//创建源File src =new File(&quot;test01/src/test03.txt&quot;);File dest =new File(&quot;test01/src/copytest.txt&quot;);//选择流InputStream is=null;OutputStream os=null;try &#123; is=new FileInputStream(src); os=new FileOutputStream(dest); byte[] flush=new byte[10]; int temp; while ((temp=is.read(flush))!=-1)&#123; os.write(flush,0,temp); &#125; os.flush();&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; //关闭流 if (null!=os)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (null!=is)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 9.字符输入流和字符输出流 1234567891011121314151617181920212223242526//字符输入流//创建源File src =new File(&quot;test01/src/test05.txt&quot;);//选择流Reader is =null;try &#123; is=new FileReader(src); char[] flush=new char[5]; int temp; while ((temp=is.read(flush))!=-1)&#123; String str=new String(flush,0,temp); System.out.println(str); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; if (null!=is) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526//字符输出流File dest=new File(&quot;test01/src/test06.txt&quot;);Writer writer=null;try &#123; writer=new FileWriter(dest); //写法一 /*String msg=&quot;我爱你田田&quot;; char[] a=msg.toCharArray(); writer.write(a,0,a.length);*/ //写法二 /*String msg=&quot;我爱你天天&quot;; writer.write(msg);*/ //写法三 writer.append(&quot;我爱你田田&quot;).append(&quot;你造吗&quot;); writer.flush();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; if (null!=writer) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","path":"2021/07/05/IO流/","date":"07-05","excerpt":"","tags":[]},{"title":"数组","text":"1.数组是相同类型数据的有序集合 2.数组的声明和创建 数组类型 数组名 =数组的值 声明 int[] array; //Java风格 int array[]; //c/c++风格 初始化 静态初始化:创建+赋值 int[] a={1,2,3,4,5} student[] stu={new student(),new student()}; 动态初始化:包含默认初始化 int[] a= new int[10]; 获取数组长度 array.length 数组的特点： 其长度是确定的。数组一旦被创建，他的大小就是不可以改变的 其元素必须是相同类型，不允许出现混合类型 数组中的元素可以是任何数据类型，包括基本类型和引用类型 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量","path":"2021/07/03/数组/","date":"07-03","excerpt":"","tags":[]},{"title":"idea的使用","text":"1.创建project后，打开view勾选toolbar/toolbatoon 2.IDEA中的Project约等于Eclipse中的workspace ​ IDEA中的Module约等于Eclipse中的Project 3.当项目较大的时候可以创建Module(模块),Module不能直接删除。如果想要删除(从硬盘上删除的那种)，需要在Module上右键Module Settings，选中Module，选择减号，移除Module属性。然后Module就有delete属性了。这样做是为了保护Module不被误删除。 4.IDEA常用设置： Appearance &amp; Bechavior(外观和行为): Appearance–&gt;Theme //设置主题 Editor–&gt;Color Scheme //改变编辑区主题 Editor–&gt;General–&gt;Change font size… //设置Ctrl+鼠标滚轮改变字体大小 Editor–&gt;General–&gt;Auto Import insert imports on paste 改成ALL 勾选Add unambiguous imports on the fly ​ Optimize imports on the fly //设置自动导包 Editor–&gt;Appearance–&gt;Show line numbers //显示行号 Editor–&gt;Appearance–&gt;Show method separators //显示方法分隔符 Editor–&gt;Editor Tabs 取消勾选Show tabs in one row //取消文件单行显示，防止以后打开的类太多找不到要 修改的类 Editor–&gt;Font //设置字体大小 Editor–&gt;File and Code Templates–&gt;Includes–&gt;File Header //设置文件头信息 Editor–&gt;File Encodings Global Encoding UTF-8 Project Encoding UTF-8 Default encoding for properties files UTF-8 //设置编码格式 Build，Execution，Deployment 勾选Build project automatically 勾选Compile independent modules in parallel //自动编译 在类上右键Split Vertically //水平显示 在类上右键Split Horizeontally //垂直显示 5.快捷键的使用 ​ 1.执行(run) alt+r ​ 2.提示补全(Class Name Completion) alt+/ ​ 3.单行注释 Ctrl+/ ​ 4.多行注释 Ctrl+shift+/ ​ 5.向下复制一行(Duplicate lines) Ctrl+alt+down ​ 6.删除一行或选中行(delete line) ctrl+d ​ 7.向下移动行(move statement down) alt+down ​ 8.向上移动行(move statement up) alt+up ​ 9.向下开始新的一行(start new line) shift+Enter ​ 10.向上开始新的一行(start new line before current) Ctrl+shift+Enter ​ 11.如何查看源码(class) Ctrl+选中指定的结构或Ctrl+shift+t ​ 12.万能解错/生成返回值变量 alt+Enter ​ 13.退回到前一个编辑的页面(back) alt+left ​ 14.进入到下一个编辑的页面(针对于上条) (forward) alt+right ​ 15.查看继承关系(type hierarchy) F4 ​ 16.格式化代码(reformat code) Ctrl+shift+f ​ 17.提示方法参数类型(Parameter Info) Ctrl+alt+/ ​ 18.复制代码 Ctrl+c ​ 19.撤销 Ctrl+z ​ 20.反撤销 Ctrl+y ​ 21.剪切 Ctrl+x ​ 22.粘贴 Ctrl+v ​ 23.保存 Ctrl+s ​ 24.全选 Ctrl+a ​ 25.选中数行，整体往后移动 tab ​ 26.选中数行，整体往前移动 shift+tab ​ 27.查看类的结构：类似于eclipse的outline Ctrl+o ​ 28.重构：修改变量名与方法名(rename) alt+shift+r ​ 29.大写转小写/小写转大写(toggle case) Ctrl+shift+y ​ 30.生成构造/get/set/tostring alt+shift+s ​ 31.查看文档说明(quick documentation) F2 ​ 32.收起所有的方法(collapse all) alt+shift+c ​ 33打开所有方法(expand all) alt+shift+x ​ 34.打开代码所在硬盘文件夹(show in explorer) Ctrl+shift+x ​ 35.生成try-catch等(surround-with) alt+shift+z ​ 36.局部变量抽取为成员变量(introduce field) alt+shift+f ​ 37.查找/替换(当前) Ctrl+f ​ 38.查找(全局) Ctrl+h ​ 39.查找文件 double shift ​ 40.查找类的继承结构图(Show UML Diagram) Ctrl+shift+u ​ 41.查看方法的多层重写结构(method hierarchy) Ctrl+alt+h ​ 42.添加到收藏(add to favorites) Ctrl+alt+f ​ 43.抽取方法(Extract Method) alt+shift+m ​ 44.打开最近修改的文件(Recently Files) Ctrl+e ​ 45.关闭当前打开的代码栏(close) Ctrl+w ​ 46.关闭打开的所有代买栏(close all) Ctrl+shift+w ​ 47.快速搜索类中的错误(next highlighted error) Ctrl+shift+q ​ 48.选择要粘贴的内容(Show in Explorer) Ctrl+shift+v ​ 49.查找方法在哪里被调用(Call Hierarchy) Ctrl+shift+h ​ 50.查看表达式的值 Ctrl+u ​ Ctrl + H 显示当前类的层次结构​ Ctrl + O 选择可重写的方法 ​ Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） ​ Ctrl + Alt + V 快速引进变量 ​ 双击shift 快速查找 6.断点调试 ​ step over 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 ​ step into 进入下一步，如果当前行断点是一个方法，则进入当前方法体内 ​ force step into 进入下一步，如果当前行断点是一个方法，则进入当前方法体内 ​ step out 跳出 ​ resume program 恢复程序运行，但如果该断点下面代码还有断点，则停在下一断电上 ​ stop 停止 ​ mute breakpoints 点中，使得所有的断点失效 ​ view breakpoints 查看所有断点 断点加在哪？ 那一块有错误加在那 断点测试看哪些区域： ​ 代码区域：看程序的执行流程​ Debug区域：看流程的执行流程​ Variables：变量的变化​ Console：看程序的输入和输出","path":"2021/07/03/idea的使用/","date":"07-03","excerpt":"","tags":[]},{"title":"二叉树","text":"1.TreeSet/TreeMap是自平衡二叉树，遵循左小右大原则存放 2.遍历二叉树的方式有三种: ​ 前序遍历:根左右 ​ 中序遍历:左根右 ​ 后序遍历:左右根 ​ 注意： ​ 前中后说的是”根”的位置。根在前边是前序，根在中间是中序，根在后边是后序。 3.TreeSet集合/TreeMap集合采用的是：中序遍历方式。左根右","path":"2021/07/02/二叉树/","date":"07-02","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2021/06/15/hello-world/","date":"06-15","excerpt":"","tags":[]},{"title":"集合","text":"什么是集合？有什么用？数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其他类型的数据。集合中不能直接存储基本数据类型、java对象，集合当中存储的都是java对象的内存地址(引用)。在java中每一个不同的集合，底层会对应不同的数据结构(数组、二叉树、链表、哈希表、图….)。集合在java jdk中的java.util.*在java中集合分为两大类一类是单个方式存储元素###单个方式存储元素，这一类集合中超级父接口：java.util.Collection&lt;br&gt; ###list接口中的常用方法 ###1.list集合存储元素特点：有序可重复 ###有序：list集合中的元素有下标。从0开始，以1递增。 ###2.list接口特有的常用方法： ###void add(int index,E element) //在列表指定位置插入指定元素 ###E get(int index) //通过下标获取元素 ###int indexof(Object o) //获取指定对象第一次出现处的索引 ###E remove(int index) //删除指定下标处的元素 ###E set(int index,E element) //修改指定位置的元素 ##ArrayList集合： ###1.默认初始化容量10 ###2.集合底层是一个Object[]数组 ###3.构造方法： ###new ArrayList(); ###new ArrayList(20); ###4.ArrayList集合的扩容： ###增长到原容量的1.5倍。 ###ArrayList集合底层是数组，怎么优化？ ###尽可能少的扩容，因为数组扩容效率比较低，建议在使用ArrayList的时候预估计元素的个数，给定一个初始化容量。 ##LinkedList集合 ###底层是双向链表数据结构 ###LinkedList的优点 ####随机增删效率较高，因为链表随机增删不设计到元素的大批量位移 ###LinkedList缺点 ####检索效率低，因为每次检索都要从头节点开始一个一个找 ##Vector集合 ###1.底层也是一个数组 ###2.初始化容量为10 ###3.怎么扩容的 ####扩容之后是原容量的2倍 ###4.Vector中的所有方法都是线程同步的，都带有synchronized关键字，是线程安全的。(效率较低不常用了) ###5.怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？ ####使用集合工具类： #####java.util.Collections; 1234567List myList = new ArrayList(); //非线程安全的//变成线程安全的Collections.synchronizedList(myList);//myList集合就是安全的了myList.add(&quot;111&quot;);myList.add(&quot;222&quot;);myList.add(&quot;333&quot;); ##HashSet集合： ###无需不可重复 ##TreeSet集合 ###1.无序不可重复，但是存储的元素自动按照大小排序，称为：可排序集合 ###2.无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标 ### 一类是以键值对儿的方式存储元素&lt;br&gt; ​ ###以键值对儿的方式存储元素，这一类集合中的超级父接口:java.util.Map ##java.util.Map： ###1.Map和Collection没有继承关系 ###2.Map集合以Key和Value的方式存储数据：键值对 ####Key和Value都是引用数据类型 ####Key和Value都是存储对象的内存地址 ####Key起到主导的地位，Value是Key的一个附属品 ###3.Map接口中的常用方法: ####void clear(); //清空Map集合 ####boolean containsKey(Object key) //判断是否包含某个key ####boolean containsValue(Object value) //判断是否包含某个value ####V get(Object key) //通过key得到Value ####boolean isEmpty() //判断Map集合中的元素个数是否为0 ####Set keySet() //获取Map集合中的所有key(所有的key是个set集合) ####V put(K key,V value) //添加键值对 ####V remove(Object key) //通过key删除键值对 ####int size() //获取Map集合中的键值对个数 ####Collection values() //获取Map集合中所有的value,返回一个Collection ####Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() //将Map集合转换成Set集合 ###Map集合的遍历 1234567891011121314151617181920212223242526272829public class mapTest &#123; public static void main(String[] args) &#123; //创建Map集合 Map&lt;Integer,String&gt; map =new HashMap(); //添加键值对 map.put(1,&quot;sun&quot;); map.put(2,&quot;ze&quot;); map.put(3,&quot;tian&quot;); //获取Map集合中所有的键 Set&lt;Integer&gt; keys = map.keySet(); 通过迭代器拿到Set集合中的key Iterator&lt;Integer&gt; it =keys.iterator(); while (it.hasNext())&#123; Integer k=it.next(); //通过拿到的key获取value值 String value =map.get(k); System.out.println(value); &#125; //第二种方式Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set=map.entrySet(); Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=set.iterator(); while (it.hasNext())&#123; Map.Entry&lt;Integer,String&gt; node=it.next(); String value=node.getValue(); System.out.println(value); &#125; &#125;&#125; ##HashMap集合： ###1.HashMap集合底层是哈希表/散列表的数据结构 ###2.哈希表是一个怎样的数据结构？ ####哈希表是一个数组和单向链表的结合体 ####数组：在查询方面效率很高，随机增删方面效率很低 ####单向链表：在随机增删方面效率较高，在查询方面效率很低 ####哈希表将以上两种数据结构融合在一起，充分发挥它们各自的优点 ###map.put(k,v)实现原理。 ###重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写HashCode()和equals() ###HashMap集合的默认初始化容量是16，默认加载因子是0.75 ####这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容，扩容之后的容量是原容量的2倍。 ####重点，记住：HashMap的初始化容量必须是2的倍数，这也是官方推荐的，这是为了达到散列均匀，为了提高HashMap集合的存取效率，所必须的。 ###在JDK8之后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构。当红黑树上的节点数量小于6时，会重新把红黑树变成单向链表数据结构。这种方式也是为了提高检索效率，二叉树的检索会再次缩小扫描范围，提高效率 ###HashMap的key和value可以为空 ###Hashtable的key和value不可以为空 ####Hashtable方法都带有synchronized:线程安全的。 ####线程安全有其他的方案，这个Hashtable对线程的处理导致效率较低，使用较少了 Hashtable和HashMap一样，底层都是哈希表数据结构 Hashtable的初始化容器是11，默认加载因子是0.75f。扩容之后是原容量*2+1 Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型 Properties被称为属性类对象 Properties是线程安全的 Properties的两个重要方法 setProperty(); //存 getProperty(); //取 1.TreeSet集合底层实际上是一个TreeMap 2.TreeMap集合底层是一个二叉树 3.放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了 4.TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序，称为：可排序集合 5.TreeSet不能排序自定义类型数据，因为自定义的数据类型没有实现Comparable接口，在底层向下转型时会出现java.lang.ClassCastException: 实现排序的第一种方式：实现Comparable接口，实现接口中的方法 实现排序的第二种方法：使用比较器 Comparable和Comparator怎么选择？ ​ 当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。 ​ Comparator接口的设计符合OCP原则。","path":"2021/05/22/集合/","date":"05-22","excerpt":"","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"我的第一篇博文","text":"我是个小可爱我真是小可爱","path":"2021/05/19/我的第一篇博文/","date":"05-19","excerpt":"","tags":[]}],"categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]}