{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Sun Zetian","url":"http://example.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"06-15","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"06-15","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"06-15","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-15","excerpt":""}],"posts":[{"title":"mysql","text":"1.初识MySQL JavaEE：企业级Java开发 Web 前端(页面：展示，数据) 后台：(连接点：链接数据库JDBC，连接前端（控制，控制试图跳转，和给前端传数据) 数据库：(存数据) 1.1为什么学习数据库 1.岗位需求 2.大数据时代 3.存数据 4.数据库是所有软件体系中最核心的存在 1.2什么是数据库 数据库(DB,DataBase) 概念：数据仓库，软件 作用：存数据，管理数据 1.3数据库分类 关系型数据库： MySQL,Oracle,Sql Server,DB2,SQLlite 通过表和表之间，行和列之间的关系进行数据存储，轩辕信息表，考勤表 非关系型数据库: Redis，MongDB 非关系型数据库，对象存储，通过对象的自身属性来决定 DBMS(数据库管理系统) 数据库的管理软件，科学有效的管理我们的数据。维护和获取数据 1.4MySQL简介 MySQL是一个关系型数据库管理系统 MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 开源，体积小，速度快 1.5链接数据库 12345678mysql -u root -p -- 连接数据库所有的语句都是用;结尾show databases; -- 查看所有的数据库use school -- 切换数据库show tables; -- 查看数据库中所有的表describe student; -- 显示数据库中所有的表信息create database westos; -- 创建一个数据库exit; -- 退出链接 数据库xxx语言 CRUD增删改查 DDL 定义 DML 操作 DQL 查询 DCL 控制 2.操作数据库 操作数据库&gt;操作数据库中的表&gt;操作数据库表中的数据 mysql不区分大小写 2.1操作数据库 1.创建数据库 1create database [if not exists] westos; 2.删除数据库 1drop database [if exists] westos; 3.使用数据库 1use `school` 4.查看数据库 1show database 2.2数据库的列类型 数值 tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 int 表准的字节 4个字节 big 较大的数据 8个字节 float 浮点数 4 double 浮点数 8 decimal 字符串形式的浮点数 金融计算时使用 字符串 char 字符串固定大小的 0-255 varchar 可变字符串 0-65535 常用变量 string tingtext 微型文本 2^8-1 text 文本串 2^16-1 保存大文件 时间日期 date YYYY-MM-DD 日期格式 time HH:mm:ss 时间格式 datetime YYYY-MM-DD HH:mm:ss 最常用的时间格式 timestamp 时间戳 year 年份表示 null 没有值，未知 注意不要使用NULL进行运算，结果为NULL 2.3数据库的字段属性 Unsigned: ​ 无符号的整数 ​ 不能声明为负数 zerfill ​ 0填充 ​ 不足的位数，使用0来填充 自增 ​ 自动在上一条记录的基础上+1 ​ 通常用来设计唯一的主键，必须是整数类型 ​ 可以自定义设计主键自增的起始值和步长 非空 Null not null ​ 设置为not null，不给赋值就会报错 默认 ​ 设置默认的值","path":"2021/07/23/mysql/","date":"07-23","excerpt":"","tags":[]},{"title":"javascript","text":"1.什么是JavaScript ​ JavaScript是一门世界上最流行的脚本语言 2.快速入门 ​ 2.1引入JavaScript ​ 1.内部标签 123&lt;script&gt; alert(&#x27;hello word!&#x27;);&lt;/script&gt; ​ 2.外部引入 1&lt;script src=&quot;js/tian.js&quot;&gt;&lt;/script&gt; ​ 2.2基本语法入门 浏览器调试 123456789//JavaScript严格区分大小写/*定义变量*/var num=1;var num1=2;/*条件控制*/if (num1&gt;num) &#123; alert(&quot;true&quot;);&#125;//console.log(num) 在浏览器控制台打印变量 ​ 2.3数据类型 数值，文本，图形，音频，视频 变量 1var a =1; number js不区分小数和整数，Number 12345123 //整数123123.1 //浮点数123.11.123e3 //科学计数法-99 //复数NaN //not a number 字符串 ‘abc’ “abc” 布尔值 true,false 逻辑运算 123&amp;&amp; 与|| 或! 非 比较运算符 123=== 等于(类型不一样，值一样，也会判断为true)=== 绝对等于(类型一样，值一样，结果为true) js的缺陷，坚决不要使用== 须知： NaN===NaN,这个与所有的数值都不想等，包括自己 只能通过isNaN(NaN)来判断这个数是否是NaN null和undefined null 空 undefined 未定义 数组 Java的数值必须是相同类型的对象，JS中不需要这样 123//保证代码的可读性，尽量使用[]var arr=[1,2,3,4,&quot;hello&quot;,null,true];new Array(1,12,3,4,4,5,&#x27;hello&#x27;); 取数组下标：如果越界了，就会undefined 对象 对象是大括号，数组是中括号 123456//Person person =new Person(1,2,3,4,5);var person=&#123; name:&quot;tian&quot;, age:3, tags:[&#x27;js&#x27;,&#x27;java&#x27;,&#x27;web&#x27;,&#x27;...&#x27;]&#125; 取对象的值 1234person.name&gt;&quot;tian&quot;person.age&gt;3 2.4严格检查模式 use strict; 严格检查模式，预防JavaScript的随意性导致产生的一些问题 必须写在第一行 3.数据类型 ​ 3.1字符串 1.正常字符串我们使用 单引号，或者双引号包裹 2.注意转义字符 \\ 3.多行字符串编写 123var msg=`helloworldnihao!` 4.模板字符串 12var name=&quot;tian&quot;;var msg1=`你好啊，$&#123;name&#125;`; 5.字符串长度 12var student=&quot;student&quot;;console.log(student.length) 6.字符串的可变性，不可变 7.大小写转换 ​ student.toUpperCase() ​ student.toLowerCase() 8.student.indexOf(‘t’) 9.substring //截取字符串 [ , ) 包头不包尾 3.2数组 Array可以包含任意的数组类型 123var arr=[1,2,3,4,50];arr[0]arr[0]=1 长度 1arr.length 注意：加入给arr.length赋值，数组大小就会发生变化，如果赋值过小，元素就会丢失 2.indexOf，通过元素获得下标索引 数字1和字符串”1”是不同的 3.slice() 截取Array的一部分，返回一个新的数组，类似于substring 4.push，pop 12push:压入尾部pop：弹出尾部的一个元素 5.unshift(),shift() 头部 12push:压入头部pop：弹出头部的一个元素 6.排序 sort() 1arr.sort() 7.元素反转 1arr1.reverse() 8.concat() //字符串拼接，没有修改原数组，只是返回了一个新数组 12arr1.concat(&quot;B&quot;,&quot;C&quot;)(8) [&quot;A&quot;, 5, 4, 3, 2, 1, &quot;B&quot;, &quot;C&quot;] 9.连接符join 打印拼接数组，使用特定的字符串拼接 12arr1.join(&quot;-&quot;)&quot;A-5-4-3-2-1&quot; 10.多维数组 123var arr=[[1,2],[3,4],[5,6]]arr[1][1]4 3.3对象 若干键值对 12345678910var 对象名=&#123; 属性名:属性值, 属性名:属性值, 属性名:属性值&#125;var person=&#123; name:&quot;tiantian&quot;, age:23, QQ:&quot;55687358&quot;&#125; js中对象，{……}表示一个对象，键值对描述属性xxxx:xxxx,多个属性之间使用逗号隔开，最后一个属性不加逗号 javascript中的键都是字符串，值可以为任意类型 1.对象赋值 1234person.name=&quot;tian&quot;&quot;tian&quot;person.name&quot;tian&quot; 2.使用一个不存在的对象属性，不会报错！undefined 3.动态的删减属性 1234delete person.nametrueperson&#123;age: 23, QQ: &quot;55687358&quot;&#125; 4.动态的添加属性 12person.haha=&quot;haha&quot;&quot;haha&quot; 5.判断属性值是否在这个对象中 xxx in xxx 12&#x27;age&#x27; in persontrue 6.判断一个属性是否是这个对象自身拥有的hasOwnProperty() 1234person.hasOwnProperty(&#x27;age&#x27;)trueperson.hasOwnProperty(&quot;toString&quot;)false 3.4流程控制 if判断 123456var age=3;if (age&gt;3)&#123; alert(&quot;haha&quot;)&#125;else&#123; alert(&quot;wuwuwu&quot;)&#125; while循环，避免程序死循环 123456789while(age&lt;100)&#123; age=age+1; console.log(age)&#125;do&#123; age=age+1; console.log(age)&#125;while(age&lt;100) for循环 123for(let i=0;i&lt;100;i++)&#123; console.log(i)&#125; 3.4Map和Set Map 12345var map=new Map([&#x27;tom&#x27;,100],[&#x27;jack&#x27;,90],[&#x27;haha&#x27;,80]);var name=map.get(&#x27;tom&#x27;);map.set(&#x27;admin&#x27;,123456);map.delete(&#x27;tom&#x27;);console.log(name); Set 123set.add(2);set.delete(1);console.log(set.has(3)); 4.函数 ​ 4.1定义函数 绝对值函数 1234567function abs(x)&#123; if(x&gt;=0)&#123; return x; &#125;else&#123; return -x; &#125;&#125; 一旦执行到return代表函数结束，返回结果 如果没有执行return，函数执行完也会返回结果，结果就是undefined 1234567var abs=function(x)&#123; if(x&gt;=0)&#123; return x; &#125;else&#123; return -x; &#125;&#125; function(x){……}这是一个匿名函数，但是可以把结果赋值给abs，通过abs调用函数 调用函数 12abs(10)abs(-10) 参数问题：JavaScript可以传任意个参数，也可以不传递参数 假设不存在参数，如何规避 12345678910var abs=function(x)&#123; if(typeof x!==&#x27;number&#x27;)&#123; throw &#x27;Not a number&#x27;; &#125; if(x&gt;=0)&#123; return x; &#125;else&#123; return -x; &#125;&#125; arguments arguments是一个JS免费赠送的关键字 代表，传递进来的所有参数，是一个数组 arguments，获取包括一定义的所有参数 rest，获取除了已经定义的参数之外的所有参数 12345function aaa(a,b,...rest)&#123; console.log(&quot;a=&gt;&quot;+a); console.log(&quot;b=&gt;&quot;+b); console.log(rest);&#125; rest参数只能写在最后面，必须用…标识 4.2变量的作用域 var定义变量实际上是有作用域的，在函数体中声明，则在函数体外不可以使用 全局函数 123456x=1;function f()&#123; console.log(x);&#125;f();console.log(x); ​ 全局对象window 1234var x=&#x27;xxx&#x27;;alert(x);alert(window.x); //默认所有的全局变量，都会自动绑定在window对象下 alert()这个函数本身也是一个window变量 js实际上只有一个全局作用域，任何变量(函数也可以视为变量),假设没有在函数作用范围内找到，就会向外查找，如果在全局作用域都没有找到，报错RefrenceError 由于我们所有的全局变量都会绑定到我们的window上，如果不同的js文件，使用了相同的全局变量，冲突-&gt;如何能够减少冲突 12345var kuangApp=&#123;&#125;;kuangApp.name=&#x27;kuangshen&#x27;;kuangApp.add=function(a,b)&#123; return a+b;&#125; 把自己的代码全部放入自己定义的唯一康健名字中，降低全局命名冲突的问题 1//局部作用域 let 建议使用let取定义局部作用域的变量 常量const 4.3方法 定义方法 方法就是把函数放在对象的里面，对象只有两个东西：属性和方法 12345678910var kuangshen=&#123; name:&#x27;qingjiang&#x27;, birth:2000, //方法 age:function()&#123; //今年-出生的年 var now=new Date().getFullYear(); return now-this.birth; &#125;&#125; 1234567891011function getAge()&#123; //今年-出生的年 var now=new Date().getFullYear(); return now-this.birth; &#125;var kuangshen=&#123; name:&#x27;qingjiang&#x27;, birth:2000, //方法 age:getAge&#125; 5.1Date 基本使用 12345678910var now =new Date(); //Thu Jul 22 2021 19:27:00 GMT+0800 (中国标准时间)now.getFullYear(); //年now.getMonth(); //月now.getDate(); //日now.getDay(); //星期几now.getHours(); //时now.getMinutes(); //分now.getSeconds(); //秒now.getTime(); //时间戳 全世界统一从1970.1.1 0：00：00开始的毫秒数console.log(new Date(1578106199999)); //Sat Jan 04 2020 10:49:59 GMT+0800 (中国标准时间) 转换 1now.toLocaleString(); 5.2 JSON json是什么 早期，所有数据传输习惯使用XML文件！ ​ JSON是一种轻量级的数据交换格式 ​ 简介和清晰的层次结构使得JSON成为理想的数据交换语言 ​ 易于阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率 在Javascript一切皆为对象，任何js支持的类型都可以用JSON来表示 格式： ​ 对象都用{} ​ 数组都用[] ​ 所有的键值对都用 key:value Json字符串和JS对象的转化 123456789var user=&#123; name:&quot;qingjiang&quot;, age:23, sex:&quot;男&quot;&#125;//对象转化为json字符串 &#123;&quot;name&quot;:&quot;qingjiang&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;男&quot;&#125;var jsonUser=JSON.stringify(user);//json字符串转化为对象，参数为json字符串var obj=JSON.parse(jsonUser); 6.面向对象编程 原型 1234567891011var student=&#123; name:&quot;qingjiang&quot;, age:23, run:function () &#123; console.log(this.name+&quot;run...&quot;); &#125;&#125;var xiaoming=&#123; name:&quot;xiaoming&quot;&#125;xiaoming.__proto__=student; class继承 class关键字，是在ES6引入的 1.定义一个类，属性，方法 12345678class student &#123; constructor(name) &#123; this.name=name; &#125; hello()&#123; alert(&quot;hello&quot;) &#125;&#125; 7.操作BOM对象 window代表 浏览器窗口 12345window.alert(1)window.innerHeightwindow.innerwidth Navigator,封装了浏览器信息 12345678navigator.appName&quot;Netscape&quot;navigator.appVersion&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36&quot;navigator.userAgent&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36&quot;navigator.platform&quot;Win32&quot; 大多数时候，我们不会使用navigator对象，因为会被人修改！不建议使用这些属性来判断和编写代码 screen 代表屏幕尺寸 1234screen.width1536screen.height864 location(重要) location代表当前页面的URL信息 1234567host: &quot;localhost:63342&quot;href: &quot;http://localhost:63342/JavaScriptTest/test01.html?_ijt=85tq7iv58sj6sfp24438rkihjg&quot;pathname: &quot;/JavaScriptTest/test01.html&quot;protocol: &quot;http:&quot;reload: ƒ reload() //刷新网页//设置新地址location.assign(&#x27;https://blog.kuangshen.com/&#x27;) document document 代表当前的页面，HTML DOM文档树 1234document.title&quot;Title&quot;document.title=&#x27;tian&#x27;&quot;tian&quot; 获取具体的文档树节点 12345678&lt;dl id=&quot;APP&quot;&gt; &lt;dt&gt;JAVA&lt;/dt&gt; &lt;dd&gt;JAVASE&lt;/dd&gt; &lt;dd&gt;JAVAEE&lt;/dd&gt;&lt;/dl&gt;&lt;script&gt;var dl=document.getElementById(&#x27;APP&#x27;);&lt;/script&gt;","path":"2021/07/19/javascript/","date":"07-19","excerpt":"","tags":[]},{"title":"css","text":"1.什么是css ​ 1.1 ​ Cascading Style Sheet层叠样式表 ​ css:表现(美化网页) ​ 字体，颜色，边距，高度，宽度…… ​ 1.2发展史 ​ css 1.0 ​ css 2.0 DIV(块)+CSS，HTML与CSS结构分离的思想，网页变得简单 ​ css 2.1 浮动，定位 ​ css 3.0 圆角，阴影，动画… 浏览器兼容性 ​ 1.3快速入门 ​ 语法: ​ 外部引入：&lt;link rel=”stylesheet” href=”” &gt; ​ 选择器{ ​ 声明1; ​ 声明2; ​ 声明3; ​ } ​ css优势 ​ 1.内容和表现分离 ​ 2.网页结构统一表现，可以实现复用 ​ 3.样式十分的丰富 ​ 4.建议使用独立于html的css文件 ​ 5.利于SEO，容易被搜索引擎收录 ​ 1.4css的三种导入方式 ​ 行内样式：在标签元素中，编写一个style属性 &lt;h1 style=&quot;color: red&quot;&gt;我是标题&lt;/h1&gt; ​ 内部样式： 12345&lt;style&gt; h1&#123; color: green; &#125;&lt;/style&gt; ​ 外部样式： 12345h1&#123; color: blue;&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; ​ 优先级：就近原则 拓展:外部样式两种写法 ​ 链接式 1&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; ​ 导入式 123&lt;style&gt; @import &quot;css/style.css&quot;;&lt;/style&gt; 2.css选择器 作用：选择页面上的某一个或者某一类元素 优先级：不遵循就近原则，id选择器&gt;类选择器&gt;标签选择器 2.1基本选择器 ​ 1.标签选择器，会选择到页面上所有的这个标签元素 ​ 2.类选择器 class，可以多个标签归类，是同一个class，跨标签 ​ 格式： ​ .class的名称{ ​ } ​ 3.Id选择器,id必须保证全局唯一 ​ 格式： ​ #id名称{ ​ } 2.2层次选择器 ​ 1.后代选择器：在某个元素的后面 123body p&#123; background: red;&#125; ​ 2.子选择器:一代,儿子 123body&gt;p&#123; background: blue;&#125; ​ 3.相邻兄弟选择器:同辈,只有一个，相邻（向下） 123.active +p&#123; background: green;&#125; ​ 4.通用兄弟选择器：当前选中元素向下的所有兄弟 123.active~p&#123; background:yellow;&#125; 2.3.结构伪类选择器 伪类：行为 123456789101112131415161718 /*选中ul中的第一个元素*/ ul li:first-child&#123; background: cornflowerblue; &#125; /*选中ul中的最后一个元素*/ ul li:last-child&#123; background: cornflowerblue; &#125;/*选中p1:定位到父元素，选择当前的第一个元素 选中当前p元素的父级元素，选中父级元素的第一个，并且是当前元素才生效！ */ p:nth-child(1)&#123; background: #188037; &#125; /*选中父元素下的p元素的第二个*/ p:nth-of-type(2)&#123; background: #488077; &#125; a:hover //鼠标悬浮的颜色 a:active //激活：鼠标按住未释放的状态 2.4属性选择器(常用) id+class结合 属性名，属性名 = 属性值(正则) 1234=绝对等于*=包含^=以...开头$=以...结尾 3.美化网页(文字，阴影，超链接，列表，渐变) span标签：重点要突出的字，使用span套起来 ​ 3.1字体样式 ​ font-family:字体 ​ font-size:字体大小 ​ font-weight:字体粗细 ​ color:字体颜色 ​ px:像素 ​ em:缩进 ​ 3.2文本样式 ​ 1.颜色 ​ 单词 ​ RGB 0~F ​ RGBA(0255) A(透明度)：01 ​ 2.文本对齐 ​ text-align:center排版居中 ​ 3.首行缩进 ​ text-indent:2em; 段落首行缩进 ​ 4.行高 ​ line-height ​ 行高和块的高度一致，就可以上下居中 ​ 5.超链接去下划线 ​ text-decoration:none ​ 6.文本图片水平对齐 ​ vertical-align：middle ​ 7.列表 ​ list-style: ​ none 去掉圆点 ​ circle 空心圆 ​ decimal 数字 ​ 8.背景 ​ border：框线 ​ 背景颜色：background-color ​ 背景图片:background-image 5.盒子模型 ​ 5.1什么是盒子模型 margin:外边距 padding:内边距 border:边框 ​ 5.2边框 ​ 1.边框的粗细 ​ 2.边框的样式 solid：实线 dashed：虚线 ​ 3.边框的颜色 ​ border:粗细 样式 颜色 ​ 外边距的妙用：居中元素 要求：块元素，块元素有固定的宽度 ​ margin：0 auto ​ 盒子的计算方式 ​ margin+border+padding+内容宽度 ​ 5.3圆角边框 ​ border-radius ​ 5.4阴影 6.浮动 1块级元素(block)：独占一行 ​ h1~h6 p div 列表 ​ 行内元素(inline)：不独占一行 ​ span a img strong ​ inline-block:保留块级元素特性但可以写在一行 ​ 行内元素可以包含在块级元素中，反之则不行 ​ 6.2display ​ float左右浮动 ​ 6.3父级边框塌陷问题 ​ clear：right；右侧不允许有浮动元素 ​ clear：left； 左侧不允许有浮动元素 ​ clear：both； 两侧都不允许有浮动元素 ​ clear：none； ​ 解决方案： ​ 1.增加父级元素的高度 ​ 2.增加一个空的div标签，清除浮动 ​ 3.在父级元素中增加一个overflow：hidden； ​ 4.父类添加一个伪类 ：after 12345#father:after&#123; content:&#x27;&#x27;; display:block; clear:both;&#125; 7.定位 ​ 7.1相对定位 ​ position:relative 相对原来的位置进行上下左右的偏移,保留原来位置 ​ 7.2绝对定位 ​ position:absolute; 相对于父级或浏览器的位置1进行指定的偏移，不在标准文档流中，原来的位置不被保留 ​ 1.没有父级元素的基于浏览器定位 ​ 2.假设父级元素存在定位，我们通常会相对于父元素进行定位 ​ 7.3 固定定位 ​ position：fixed； ​ 7.4 z-index 默认0 8.网页动画(特效效果)","path":"2021/07/16/css/","date":"07-16","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"html","text":"1.html注释 2. 网页头部 3. 网页主体 4. 网页标题 5. 描述性标签，用来描述网站的信息 基本标签： 1.标题标签 h1-h6 一级标签 二级标签 段落标签 p 换行标签 br 水平线标签 hr 字体样式标签 ​ 粗体：strong粗体 ​ 斜体：em斜体 特殊符号 空格：&amp;nbsp； ​ 空&nbsp;&nbsp;格 大于号：&amp;gt； 小于号：&amp;lt； 版权符号：&amp;copy； 2.常见的图片格式 ​ JPG ​ GIF ​ PNG ​ BMP 位图 嵌入图片：&lt;img src=”path” alt=”text” title=”text” width=”x” height=”y” /&gt; 3.链接标签：&lt;a href=” “ target=” “&gt;&lt;/a&gt; ​ href: 必填，表示要跳转到哪个页面 ​ target:表示窗口在哪里打开 ​ _blank 在新标签打开 ​ _self 在自己的网页中打开 锚链接： ​ 1.需要一个锚标记 ​ 2.跳转到标记 使用name做标记，#name跳转 功能性链接： ​ 邮件链接：mailto: ​ &lt;a href=”mailto:&#53;&#x35;&#54;&#x38;&#x37;&#51;&#x35;&#x38;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;“ &gt;&lt;/a&gt; 行内元素和块元素 块元素： ​ 无论内容多少，该元素独占一行 行内元素： ​ 内容撑开宽度，左右都是行内元素的可以排在一行 列表 ​ 有序列表 ​ &lt;ol&gt; ​ &lt;li&gt;&lt;/li&gt; ​ &lt;/ol&gt; ​ 无序列表(应用范围：导航栏、侧边栏……) ​ &lt;ul&gt; ​ &lt;li&gt;&lt;/li&gt; ​ &lt;/ul&gt; ​ 自定义列表 ​ dl:标签 ​ dt:列表名称 ​ dd:列表选项 ​ &lt;dl&gt; ​ &lt;dt&gt;&lt;/dt&gt; ​ &lt;dd&gt;&lt;/dd&gt; ​ &lt;/dl&gt; 表格table： ​ 行：tr rows ​ 列：td colspan：跨列 rowspan：跨行 视频video ​ &lt;video src=”” controls autoplay&gt;&lt;/video&gt; 音频audio ​ &lt;audio src=”” controls autoplay&gt;&lt;/audio&gt; 页面结构分析 header：标题头部区域的内容 footer：标记脚步区域的内容 section：Web页面中的一块独立区域 article：独立的文章内容 aside：相关内容或应用(常用于侧边栏) nav:导航类辅助内容 iframe内联框架 ​ &lt;iframe src=” “ frameborder=”0” width=” “ height=” “&gt;&lt;/iframe&gt; 表单语法 ​ action:表单提交的位置，可以是网站，也可以是一个请求处理地址 ​ method: post，get 提交方式 ​ get方式提交：我们可以在url中看到我们提交的信息，不安全，高效 ​ post方式：比较安全，传输大文件 ​ &lt;form action=”#” method=”get”&gt;&lt;/form&gt; ​ ​ &lt;p&gt;名字：&lt;input type=”text” name=”username”&gt;&lt;/input&gt;&lt;/p&gt; ​ ​ &lt;p&gt;名字：&lt;input type=”password” name=”pwd”&gt;&lt;/input&gt;&lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”radio” value=”boy” name=”sex”/&gt;男 ​ &lt;input type=”radio” value=”girl” name=”sex”/&gt;女 ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”checkbox” value=”sleep” name=”hobby”/&gt;睡觉 ​ &lt;input type=”checkbox” value=”code” name=”hobby”/&gt;敲代码 ​ &lt;input type=”checkbox” value=”chat” name=”hobby”/&gt;聊天 ​ &lt;input type=”checkbox” value=”game” name=”hobby”/&gt;游戏 ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”button” name=”btn1” value=” “&gt; //普通按钮 ​ &lt;input type=”image” src=” “&gt; //图像按钮 ​ &lt;/P&gt; ​ ​ &lt;p&gt;下拉框： ​ &lt;select name=”列表名称”&gt; ​ &lt;option value=”选项的值”&gt;&lt;/option&gt; ​ &lt;/select&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt;反馈： ​ &lt;textarea name=”textarea”&gt;&lt;/textarea&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”file” name=”files”&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt;&lt;input type=”submit” &gt;&lt;input type=”reset”&gt;&lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”email” name=”email”&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”url” name=”url”&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”number” name=”number” max=”100” min=”0” step=”10”&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”range” name=”voice” max=”100” min=”0” step=”10”&gt; ​ &lt;/p&gt; ​ ​ &lt;p&gt; ​ &lt;input type=”search” name=”search”&gt; ​ &lt;/p&gt; &lt;label for=”mark”&gt;&lt;/label&gt; &lt;input type=”text” id=”mark”&gt; 隐藏域 hidden 只读 readonly 禁用 disabled 表单初级验证 placeholder 提示信息 required 非空判断 pattern 正则表达式","path":"2021/07/14/html/","date":"07-14","excerpt":"","tags":[{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"}]},{"title":"IO流","text":"1.流：流动、流向，从一端移动到另一端。流是一个抽象、动态的概念，是一连串连续动态的数据集合。 2.核心类： File 文件类 由File类提供了描述文件和目录的操作与管理方法。但File类不是InputStream、OutputStream或Reader、Writer的子类，因为它不负责数据的输入输出，而专门用来管理磁盘文件与目录。 四大抽象类： InputStream 字节输入流 OutputStream 字节输出流 Reader 字符输入流 Writer 字符输出流 Closeable 关闭流接口 Flushable 刷新流接口 Serializable 序列化接口 3.名称分隔符 建议 1./ path=”D:/java300/IO_study01/IO.png”; 2.常量拼接 path=”D:”+File.separator+”java300”+File.separator+”IO_study01”+File.separator+”IO_png”; 3.构造File对象 4.File常用方法 getName() 获取名字 getPath() 获取路径 getAbsolutePath() 返回绝对路径 getParent() 返回上路径，如果没有返回空 exists() 判断是否存在 isFile() 判断是否是文件 isDirectory() 判断是否是文件夹 length() 获取文件大小，字节数 createNewFile() 创建新文件，不存在才创建 delete() 删除文件 mkdir() 创建目录必须保证父目录存在 mkdirs() 创建目录，如果父路径不存在会自动创建父目录 list() 获取下级名称 listFiles() 获取下级File对象 listRoots() 根目录 5. 编码:字符(能看懂的)–&gt;字节(看不懂的) 解码:字节(看不懂的)–&gt;字符(能看懂的) 代码解释则是 12345678String(byte[] bytes, String charsetName):通过指定的字符集解码字节数组byte[] getBytes(String charsetName):使用指定的字符集合把字符串编码为字节数组编码:把看得懂的变成看不懂的String -- byte[]解码:把看不懂的变成看得懂的byte[] -- String 6.IO流操作步骤 ​ 1.创建流 ​ 2.选择流 ​ 3.操作 ​ 4.释放资源 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;public class IoTest &#123; public static void main(String[] args) &#123; //创建源 File src=new File(&quot;E:/ideajavaproject/debugtest/test01/src/test02.txt&quot;); //选择流 InputStream is =null; try &#123; is = new FileInputStream(src); /*int temp =is.read(); 这样写把temp定死了是第一个字符 所以下边的循环会成为死循环，循环输出第一个字符 while (temp!=-1)&#123; System.out.println((char)temp); &#125;*/ int temp; //只有这样写在下边执行循环时才能每次给temp赋值，每次取下一个，直到读取完返回-1，循环结束 while((temp=is.read())!=-1)&#123; System.out.println((char)temp); &#125; /*int date1 =is.read(); int date2 =is.read(); int date3 =is.read(); int date4 =is.read(); int date5 =is.read(); System.out.println((char)date1); System.out.println((char)date2); System.out.println((char)date3); System.out.println((char)date4); System.out.println((char)date5);*/ &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (null!=is) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 7.输出流在使用后要flush，避免数据驻留在内存中。 8.文件copy 示例代码： 123456789101112131415161718192021222324252627282930313233343536//创建源File src =new File(&quot;test01/src/test03.txt&quot;);File dest =new File(&quot;test01/src/copytest.txt&quot;);//选择流InputStream is=null;OutputStream os=null;try &#123; is=new FileInputStream(src); os=new FileOutputStream(dest); byte[] flush=new byte[10]; int temp; while ((temp=is.read(flush))!=-1)&#123; os.write(flush,0,temp); &#125; os.flush();&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; //关闭流 if (null!=os)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (null!=is)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 9.字符输入流和字符输出流 1234567891011121314151617181920212223242526//字符输入流//创建源File src =new File(&quot;test01/src/test05.txt&quot;);//选择流Reader is =null;try &#123; is=new FileReader(src); char[] flush=new char[5]; int temp; while ((temp=is.read(flush))!=-1)&#123; String str=new String(flush,0,temp); System.out.println(str); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; if (null!=is) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526//字符输出流File dest=new File(&quot;test01/src/test06.txt&quot;);Writer writer=null;try &#123; writer=new FileWriter(dest); //写法一 /*String msg=&quot;我爱你田田&quot;; char[] a=msg.toCharArray(); writer.write(a,0,a.length);*/ //写法二 /*String msg=&quot;我爱你天天&quot;; writer.write(msg);*/ //写法三 writer.append(&quot;我爱你田田&quot;).append(&quot;你造吗&quot;); writer.flush();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; if (null!=writer) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","path":"2021/07/05/IO流/","date":"07-05","excerpt":"","tags":[]},{"title":"数组","text":"1.数组是相同类型数据的有序集合 2.数组的声明和创建 数组类型 数组名 =数组的值 声明 int[] array; //Java风格 int array[]; //c/c++风格 初始化 静态初始化:创建+赋值 int[] a={1,2,3,4,5} student[] stu={new student(),new student()}; 动态初始化:包含默认初始化 int[] a= new int[10]; 获取数组长度 array.length 数组的特点： 其长度是确定的。数组一旦被创建，他的大小就是不可以改变的 其元素必须是相同类型，不允许出现混合类型 数组中的元素可以是任何数据类型，包括基本类型和引用类型 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量","path":"2021/07/03/数组/","date":"07-03","excerpt":"","tags":[]},{"title":"异常","text":"1.异常分为三种类型： 检查性异常：用户错误或问题引起的异常 运行时异常：运行时异常时可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略 错误：错误不是异常，二十脱离程序员控制的问题。错误在代码中通常被忽略 2.自定义异常类 只需要继承Exception","path":"2021/07/03/异常/","date":"07-03","excerpt":"","tags":[]},{"title":"idea的使用","text":"1.创建project后，打开view勾选toolbar/toolbatoon 2.IDEA中的Project约等于Eclipse中的workspace ​ IDEA中的Module约等于Eclipse中的Project 3.当项目较大的时候可以创建Module(模块),Module不能直接删除。如果想要删除(从硬盘上删除的那种)，需要在Module上右键Module Settings，选中Module，选择减号，移除Module属性。然后Module就有delete属性了。这样做是为了保护Module不被误删除。 4.IDEA常用设置： Appearance &amp; Bechavior(外观和行为): Appearance–&gt;Theme //设置主题 Editor–&gt;Color Scheme //改变编辑区主题 Editor–&gt;General–&gt;Change font size… //设置Ctrl+鼠标滚轮改变字体大小 Editor–&gt;General–&gt;Auto Import insert imports on paste 改成ALL 勾选Add unambiguous imports on the fly ​ Optimize imports on the fly //设置自动导包 Editor–&gt;Appearance–&gt;Show line numbers //显示行号 Editor–&gt;Appearance–&gt;Show method separators //显示方法分隔符 Editor–&gt;Editor Tabs 取消勾选Show tabs in one row //取消文件单行显示，防止以后打开的类太多找不到要 修改的类 Editor–&gt;Font //设置字体大小 Editor–&gt;File and Code Templates–&gt;Includes–&gt;File Header //设置文件头信息 Editor–&gt;File Encodings Global Encoding UTF-8 Project Encoding UTF-8 Default encoding for properties files UTF-8 //设置编码格式 Build，Execution，Deployment 勾选Build project automatically 勾选Compile independent modules in parallel //自动编译 在类上右键Split Vertically //水平显示 在类上右键Split Horizeontally //垂直显示 5.快捷键的使用 ​ 1.执行(run) alt+r ​ 2.提示补全(Class Name Completion) alt+/ ​ 3.单行注释 Ctrl+/ ​ 4.多行注释 Ctrl+shift+/ ​ 5.向下复制一行(Duplicate lines) Ctrl+alt+down ​ 6.删除一行或选中行(delete line) ctrl+d ​ 7.向下移动行(move statement down) alt+down ​ 8.向上移动行(move statement up) alt+up ​ 9.向下开始新的一行(start new line) shift+Enter ​ 10.向上开始新的一行(start new line before current) Ctrl+shift+Enter ​ 11.如何查看源码(class) Ctrl+选中指定的结构或Ctrl+shift+t ​ 12.万能解错/生成返回值变量 alt+Enter ​ 13.退回到前一个编辑的页面(back) alt+left ​ 14.进入到下一个编辑的页面(针对于上条) (forward) alt+right ​ 15.查看继承关系(type hierarchy) F4 ​ 16.格式化代码(reformat code) Ctrl+shift+f ​ 17.提示方法参数类型(Parameter Info) Ctrl+alt+/ ​ 18.复制代码 Ctrl+c ​ 19.撤销 Ctrl+z ​ 20.反撤销 Ctrl+y ​ 21.剪切 Ctrl+x ​ 22.粘贴 Ctrl+v ​ 23.保存 Ctrl+s ​ 24.全选 Ctrl+a ​ 25.选中数行，整体往后移动 tab ​ 26.选中数行，整体往前移动 shift+tab ​ 27.查看类的结构：类似于eclipse的outline Ctrl+o ​ 28.重构：修改变量名与方法名(rename) alt+shift+r ​ 29.大写转小写/小写转大写(toggle case) Ctrl+shift+y ​ 30.生成构造/get/set/tostring alt+shift+s ​ 31.查看文档说明(quick documentation) F2 ​ 32.收起所有的方法(collapse all) alt+shift+c ​ 33打开所有方法(expand all) alt+shift+x ​ 34.打开代码所在硬盘文件夹(show in explorer) Ctrl+shift+x ​ 35.生成try-catch等(surround-with) alt+shift+z ​ 36.局部变量抽取为成员变量(introduce field) alt+shift+f ​ 37.查找/替换(当前) Ctrl+f ​ 38.查找(全局) Ctrl+h ​ 39.查找文件 double shift ​ 40.查找类的继承结构图(Show UML Diagram) Ctrl+shift+u ​ 41.查看方法的多层重写结构(method hierarchy) Ctrl+alt+h ​ 42.添加到收藏(add to favorites) Ctrl+alt+f ​ 43.抽取方法(Extract Method) alt+shift+m ​ 44.打开最近修改的文件(Recently Files) Ctrl+e ​ 45.关闭当前打开的代码栏(close) Ctrl+w ​ 46.关闭打开的所有代买栏(close all) Ctrl+shift+w ​ 47.快速搜索类中的错误(next highlighted error) Ctrl+shift+q ​ 48.选择要粘贴的内容(Show in Explorer) Ctrl+shift+v ​ 49.查找方法在哪里被调用(Call Hierarchy) Ctrl+shift+h ​ 50.查看表达式的值 Ctrl+u ​ Ctrl + H 显示当前类的层次结构​ Ctrl + O 选择可重写的方法 ​ Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） ​ Ctrl + Alt + V 快速引进变量 ​ 双击shift 快速查找 6.断点调试 ​ step over 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 ​ step into 进入下一步，如果当前行断点是一个方法，则进入当前方法体内 ​ force step into 进入下一步，如果当前行断点是一个方法，则进入当前方法体内 ​ step out 跳出 ​ resume program 恢复程序运行，但如果该断点下面代码还有断点，则停在下一断电上 ​ stop 停止 ​ mute breakpoints 点中，使得所有的断点失效 ​ view breakpoints 查看所有断点 断点加在哪？ 那一块有错误加在那 断点测试看哪些区域： ​ 代码区域：看程序的执行流程​ Debug区域：看流程的执行流程​ Variables：变量的变化​ Console：看程序的输入和输出","path":"2021/07/03/idea的使用/","date":"07-03","excerpt":"","tags":[]},{"title":"二叉树","text":"1.TreeSet/TreeMap是自平衡二叉树，遵循左小右大原则存放 2.遍历二叉树的方式有三种: ​ 前序遍历:根左右 ​ 中序遍历:左根右 ​ 后序遍历:左右根 ​ 注意： ​ 前中后说的是”根”的位置。根在前边是前序，根在中间是中序，根在后边是后序。 3.TreeSet集合/TreeMap集合采用的是：中序遍历方式。左根右","path":"2021/07/02/二叉树/","date":"07-02","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2021/06/15/hello-world/","date":"06-15","excerpt":"","tags":[]},{"title":"集合","text":"什么是集合？有什么用？数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其他类型的数据。集合中不能直接存储基本数据类型、java对象，集合当中存储的都是java对象的内存地址(引用)。在java中每一个不同的集合，底层会对应不同的数据结构(数组、二叉树、链表、哈希表、图….)。集合在java jdk中的java.util.*在java中集合分为两大类一类是单个方式存储元素###单个方式存储元素，这一类集合中超级父接口：java.util.Collection&lt;br&gt; ###list接口中的常用方法 ###1.list集合存储元素特点：有序可重复 ###有序：list集合中的元素有下标。从0开始，以1递增。 ###2.list接口特有的常用方法： ###void add(int index,E element) //在列表指定位置插入指定元素 ###E get(int index) //通过下标获取元素 ###int indexof(Object o) //获取指定对象第一次出现处的索引 ###E remove(int index) //删除指定下标处的元素 ###E set(int index,E element) //修改指定位置的元素 ##ArrayList集合： ###1.默认初始化容量10 ###2.集合底层是一个Object[]数组 ###3.构造方法： ###new ArrayList(); ###new ArrayList(20); ###4.ArrayList集合的扩容： ###增长到原容量的1.5倍。 ###ArrayList集合底层是数组，怎么优化？ ###尽可能少的扩容，因为数组扩容效率比较低，建议在使用ArrayList的时候预估计元素的个数，给定一个初始化容量。 ##LinkedList集合 ###底层是双向链表数据结构 ###LinkedList的优点 ####随机增删效率较高，因为链表随机增删不设计到元素的大批量位移 ###LinkedList缺点 ####检索效率低，因为每次检索都要从头节点开始一个一个找 ##Vector集合 ###1.底层也是一个数组 ###2.初始化容量为10 ###3.怎么扩容的 ####扩容之后是原容量的2倍 ###4.Vector中的所有方法都是线程同步的，都带有synchronized关键字，是线程安全的。(效率较低不常用了) ###5.怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？ ####使用集合工具类： #####java.util.Collections; 1234567List myList = new ArrayList(); //非线程安全的//变成线程安全的Collections.synchronizedList(myList);//myList集合就是安全的了myList.add(&quot;111&quot;);myList.add(&quot;222&quot;);myList.add(&quot;333&quot;); ##HashSet集合： ###无需不可重复 ##TreeSet集合 ###1.无序不可重复，但是存储的元素自动按照大小排序，称为：可排序集合 ###2.无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标 ### 一类是以键值对儿的方式存储元素&lt;br&gt; ​ ###以键值对儿的方式存储元素，这一类集合中的超级父接口:java.util.Map ##java.util.Map： ###1.Map和Collection没有继承关系 ###2.Map集合以Key和Value的方式存储数据：键值对 ####Key和Value都是引用数据类型 ####Key和Value都是存储对象的内存地址 ####Key起到主导的地位，Value是Key的一个附属品 ###3.Map接口中的常用方法: ####void clear(); //清空Map集合 ####boolean containsKey(Object key) //判断是否包含某个key ####boolean containsValue(Object value) //判断是否包含某个value ####V get(Object key) //通过key得到Value ####boolean isEmpty() //判断Map集合中的元素个数是否为0 ####Set keySet() //获取Map集合中的所有key(所有的key是个set集合) ####V put(K key,V value) //添加键值对 ####V remove(Object key) //通过key删除键值对 ####int size() //获取Map集合中的键值对个数 ####Collection values() //获取Map集合中所有的value,返回一个Collection ####Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() //将Map集合转换成Set集合 ###Map集合的遍历 1234567891011121314151617181920212223242526272829public class mapTest &#123; public static void main(String[] args) &#123; //创建Map集合 Map&lt;Integer,String&gt; map =new HashMap(); //添加键值对 map.put(1,&quot;sun&quot;); map.put(2,&quot;ze&quot;); map.put(3,&quot;tian&quot;); //获取Map集合中所有的键 Set&lt;Integer&gt; keys = map.keySet(); 通过迭代器拿到Set集合中的key Iterator&lt;Integer&gt; it =keys.iterator(); while (it.hasNext())&#123; Integer k=it.next(); //通过拿到的key获取value值 String value =map.get(k); System.out.println(value); &#125; //第二种方式Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set=map.entrySet(); Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=set.iterator(); while (it.hasNext())&#123; Map.Entry&lt;Integer,String&gt; node=it.next(); String value=node.getValue(); System.out.println(value); &#125; &#125;&#125; ##HashMap集合： ###1.HashMap集合底层是哈希表/散列表的数据结构 ###2.哈希表是一个怎样的数据结构？ ####哈希表是一个数组和单向链表的结合体 ####数组：在查询方面效率很高，随机增删方面效率很低 ####单向链表：在随机增删方面效率较高，在查询方面效率很低 ####哈希表将以上两种数据结构融合在一起，充分发挥它们各自的优点 ###map.put(k,v)实现原理。 ###重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写HashCode()和equals() ###HashMap集合的默认初始化容量是16，默认加载因子是0.75 ####这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容，扩容之后的容量是原容量的2倍。 ####重点，记住：HashMap的初始化容量必须是2的倍数，这也是官方推荐的，这是为了达到散列均匀，为了提高HashMap集合的存取效率，所必须的。 ###在JDK8之后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构。当红黑树上的节点数量小于6时，会重新把红黑树变成单向链表数据结构。这种方式也是为了提高检索效率，二叉树的检索会再次缩小扫描范围，提高效率 ###HashMap的key和value可以为空 ###Hashtable的key和value不可以为空 ####Hashtable方法都带有synchronized:线程安全的。 ####线程安全有其他的方案，这个Hashtable对线程的处理导致效率较低，使用较少了 Hashtable和HashMap一样，底层都是哈希表数据结构 Hashtable的初始化容器是11，默认加载因子是0.75f。扩容之后是原容量*2+1 Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型 Properties被称为属性类对象 Properties是线程安全的 Properties的两个重要方法 setProperty(); //存 getProperty(); //取 1.TreeSet集合底层实际上是一个TreeMap 2.TreeMap集合底层是一个二叉树 3.放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了 4.TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序，称为：可排序集合 5.TreeSet不能排序自定义类型数据，因为自定义的数据类型没有实现Comparable接口，在底层向下转型时会出现java.lang.ClassCastException: 实现排序的第一种方式：实现Comparable接口，实现接口中的方法 实现排序的第二种方法：使用比较器 Comparable和Comparator怎么选择？ ​ 当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。 ​ Comparator接口的设计符合OCP原则。","path":"2021/05/22/集合/","date":"05-22","excerpt":"","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"我的第一篇博文","text":"我是个小可爱我真是小可爱","path":"2021/05/19/我的第一篇博文/","date":"05-19","excerpt":"","tags":[]}],"categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]}