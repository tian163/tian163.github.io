{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Sun Zetian","url":"http://example.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"06-15","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"06-15","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"06-15","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-15","excerpt":""}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2021/06/15/hello-world/","date":"06-15","excerpt":"","tags":[]},{"title":"集合","text":"什么是集合？有什么用？数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其他类型的数据。集合中不能直接存储基本数据类型、java对象，集合当中存储的都是java对象的内存地址(引用)。在java中每一个不同的集合，底层会对应不同的数据结构(数组、二叉树、链表、哈希表、图….)。集合在java jdk中的java.util.*在java中集合分为两大类一类是单个方式存储元素###单个方式存储元素，这一类集合中超级父接口：java.util.Collection&lt;br&gt; ###list接口中的常用方法 ###1.list集合存储元素特点：有序可重复 ###有序：list集合中的元素有下标。从0开始，以1递增。 ###2.list接口特有的常用方法： ###void add(int index,E element) //在列表指定位置插入指定元素 ###E get(int index) //通过下标获取元素 ###int indexof(Object o) //获取指定对象第一次出现处的索引 ###E remove(int index) //删除指定下标处的元素 ###E set(int index,E element) //修改指定位置的元素 ##ArrayList集合： ###1.默认初始化容量10 ###2.集合底层是一个Object[]数组 ###3.构造方法： ###new ArrayList(); ###new ArrayList(20); ###4.ArrayList集合的扩容： ###增长到原容量的1.5倍。 ###ArrayList集合底层是数组，怎么优化？ ###尽可能少的扩容，因为数组扩容效率比较低，建议在使用ArrayList的时候预估计元素的个数，给定一个初始化容量。 ##LinkedList集合 ###底层是双向链表数据结构 ###LinkedList的优点 ####随机增删效率较高，因为链表随机增删不设计到元素的大批量位移 ###LinkedList缺点 ####检索效率低，因为每次检索都要从头节点开始一个一个找 ##Vector集合 ###1.底层也是一个数组 ###2.初始化容量为10 ###3.怎么扩容的 ####扩容之后是原容量的2倍 ###4.Vector中的所有方法都是线程同步的，都带有synchronized关键字，是线程安全的。(效率较低不常用了) ###5.怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？ ####使用集合工具类： #####java.util.Collections; 1234567List myList = new ArrayList(); //非线程安全的//变成线程安全的Collections.synchronizedList(myList);//myList集合就是安全的了myList.add(&quot;111&quot;);myList.add(&quot;222&quot;);myList.add(&quot;333&quot;); ##HashSet集合： ###无需不可重复 ##TreeSet集合 ###1.无序不可重复，但是存储的元素自动按照大小排序，称为：可排序集合 ###2.无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标 ### 一类是以键值对儿的方式存储元素&lt;br&gt; ​ ###以键值对儿的方式存储元素，这一类集合中的超级父接口:java.util.Map ##java.util.Map： ###1.Map和Collection没有继承关系 ###2.Map集合以Key和Value的方式存储数据：键值对 ####Key和Value都是引用数据类型 ####Key和Value都是存储对象的内存地址 ####Key起到主导的地位，Value是Key的一个附属品 ###3.Map接口中的常用方法: ####void clear(); //清空Map集合 ####boolean containsKey(Object key) //判断是否包含某个key ####boolean containsValue(Object value) //判断是否包含某个value ####V get(Object key) //通过key得到Value ####boolean isEmpty() //判断Map集合中的元素个数是否为0 ####Set keySet() //获取Map集合中的所有key(所有的key是个set集合) ####V put(K key,V value) //添加键值对 ####V remove(Object key) //通过key删除键值对 ####int size() //获取Map集合中的键值对个数 ####Collection values() //获取Map集合中所有的value,返回一个Collection ####Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() //将Map集合转换成Set集合 ###Map集合的遍历 1234567891011121314151617181920212223242526272829public class mapTest &#123; public static void main(String[] args) &#123; //创建Map集合 Map&lt;Integer,String&gt; map =new HashMap(); //添加键值对 map.put(1,&quot;sun&quot;); map.put(2,&quot;ze&quot;); map.put(3,&quot;tian&quot;); //获取Map集合中所有的键 Set&lt;Integer&gt; keys = map.keySet(); 通过迭代器拿到Set集合中的key Iterator&lt;Integer&gt; it =keys.iterator(); while (it.hasNext())&#123; Integer k=it.next(); //通过拿到的key获取value值 String value =map.get(k); System.out.println(value); &#125; //第二种方式Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set=map.entrySet(); Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=set.iterator(); while (it.hasNext())&#123; Map.Entry&lt;Integer,String&gt; node=it.next(); String value=node.getValue(); System.out.println(value); &#125; &#125;&#125; ##HashMap集合： ###1.HashMap集合底层是哈希表/散列表的数据结构 ###2.哈希表是一个怎样的数据结构？ ####哈希表是一个数组和单向链表的结合体 ####数组：在查询方面效率很高，随机增删方面效率很低 ####单向链表：在随机增删方面效率较高，在查询方面效率很低 ####哈希表将以上两种数据结构融合在一起，充分发挥它们各自的优点 ###map.put(k,v)实现原理。 ###重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写HashCode()和equals() ###HashMap集合的默认初始化容量是16，默认加载因子是0.75 ####这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容，扩容之后的容量是原容量的2倍。 ####重点，记住：HashMap的初始化容量必须是2的倍数，这也是官方推荐的，这是为了达到散列均匀，为了提高HashMap集合的存取效率，所必须的。 ###在JDK8之后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构。当红黑树上的节点数量小于6时，会重新把红黑树变成单向链表数据结构。这种方式也是为了提高检索效率，二叉树的检索会再次缩小扫描范围，提高效率 ###HashMap的key和value可以为空 ###Hashtable的key和value不可以为空 ####Hashtable方法都带有synchronized:线程安全的。 ####线程安全有其他的方案，这个Hashtable对线程的处理导致效率较低，使用较少了 ###Hashtable和HashMap一样，底层都是哈希表数据结构 ####Hashtable的初始化容器是11，默认加载因子是0.75f。扩容之后是原容量*2+1 ###Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型 ###Properties被称为属性类对象 ###Properties是线程安全的 ###Properties的两个重要方法 ####setProperty(); //存 ####getProperty(); //取 ###1.TreeSet集合底层实际上是一个TreeMap ###2.TreeMap集合底层是一个二叉树 ###3.放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了 ###4.TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序，称为：可排序集合","path":"2021/05/22/集合/","date":"05-22","excerpt":"","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"我的第一篇博文","text":"我是个小可爱我真是小可爱","path":"2021/05/19/我的第一篇博文/","date":"05-19","excerpt":"","tags":[]}],"categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]}